---
title: "템플릿(Template)"
categories:
  - cpp
tags:
  - tag
---
> ## 개요

Template을 한국어로 번역하면 형판이라는 단어가 나옵니다. 어떠한 물건을 찍어내는 틀을 의미하는 단어이고,<br>
C++ 언어에서도 같은 의미로 사용자가 원하는 타입을 넣어주면 그에 맞춰 코드를 찍어주는 틀이라고 볼 수 있습니다.<br>
템플릿은 제네릭 프로그래밍을 위해 만들어져 재사용성을 높이는 역할을 합니다.<br>
<br>
어떤 함수 템플릿이 호출되면 컴파일러가 인스턴스를 만듭니다.(템플릿 인스턴스화가 진행됩니다.)<br>
각 인스턴스는 특수화된 템플릿 함수의 버전입니다.

템플릿을 만들려고 했던 동기는 사용자가 타입에 관계없는 컨테이너를 만들어 사용할 때 타입 안정성을 부여할 수 있도록 하는 것이였습니다.<br>
그런데 이 템플릿을 가지고 노는 사람들이 많아지면서 이것으로 할 수 있는 일들도 차츰 더 많이 발견되었습니다.

> ## 선언

템플릿의 종류를 설명하기 앞서 공통적으로 사용되는<br>
선언 방법에 대해 설명하고 넘어가겠습니다.
### 키워드
먼저 template 키워드를 선언하는 방법입니다.
```cpp
template<typename T>
template<class T>
```
T는 형식 매개 변수라 합니다. typename은 알수 없는 T라는 식별자가 형식이라는 힌트를 제공하는 키워드입니다.<br>
typename 대신 class 키워드를 사용할 수 있는데 두 키워드는 같은 의미를 가졌습니다.<br>
<br>
(기존 C++을 구현할 당시 새로운 키워드를 만들고 싶지 않아서 class를 사용하였다고 합니다.<br>
허나 이후 생기는 혼동으로 인하여 typename 이라는 키워드를 생성하였습니다.<br>
따라서 class 보다는 typename 키워드를 사용하는 것을 권장하고 있습니다.)

### 형식 매개 변수
형식 매개 변수의 개수에 실질적인 제약은 존재하지 않습니다.<br>
모든 기본 제공 또는 사용자 정의 형식을 형식 매개 변수로 사용할 수 있습니다.
```cpp
template<typename T,  typename U, typename V ...>
```
### 값 매개 변수
형식이 아닌 매개 변수도 지원합니다. 이를 값 매개 변수라고 합니다.<br>
사용법은 다음과 같습니다.
```cpp
template <typename T, int num> //int num 선언
```
### 기본값
매개 변수들은 default값을 지정해 줄 수 있습니다.<br>
형식 매개 변수는 형식에 대한 기본 값을, 값 매개변수는 값에 대한 기본값을 지정받을 수 있습니다.
```cpp
template <typename T = int, int num = 5> //int와 5를 default 값으로 지정했다.
```
> ## 종류

템플릿의 사용은 크게 2가지 종류로 나뉜다고 볼 수 있습니다. 하나는 함수 템플릿이고 두번째는 클래스 템플릿입니다.<br>
두 가지 사용방법에 대해 서술하겠습니다.
### 함수 템플릿
함수 템플릿은 함수를 템플릿화 시키는 방법입니다.

#### 형식 매개 변수
먼저 T라는 형식 매개 변수를 받는 함수를 구현하였습니다.
```cpp
T min_num(const T& lhs, const T& rhs) {
	return lhs < rhs ? lhs : rhs;
}
void main(void) {
	std::cout << min_num<int>(1, 2) << std::endl;
	std::cout << min_num<float>(0.1f, 0.2f) << std::endl;
	std::cout << min_num(0.1, 0.2) << std::endl; //double로 암시적 변환 <>만 붙여도 됩니다!
}
```
함수 템플릿의 경우 T라는 형식을 알리기 위해 <형식>을 사용했습니다.<br>
허나 사용하지 않아도 함수의 매개변수를 판단해 암시적으로 템플릿 인스턴스화 됩니다.<br>
위 코드는 min_num\<int\>, min_num\<float\>, min_num\<double\> 의 템플릿 인스턴스가 이루어졌습니다.
#### 값 매개 변수
이번에는 값 매개 변수가 존재할 때의 함수 템플릿 사용 방법입니다.
```cpp
template <typename T, int num> //int num 값 매개 변수 선언
T add_num(const T& t) { //int num을 선언하지 않습니다.
	return t + num;
}
template <typename T, int num = 2> //기본 값 선언
T minus_num(const T& t) {
	return t - num;
}
void main(void) {
	std::cout << add_num<int, 2>(1) << std::endl;
	std::cout << minus_num<>(1) << std::endl; //기본값이 있으면 값을 주지 않아도 됩니다.
}
```
한가지 주의해야 할 점은 int num의 값 매개 변수를 함수의 매개 변수에 넣지 않는다는 점입니다.<br>
또한 값 매개 변수에 기본값이 존재할 경우 명시적인 선언을 해 줄 필요가 없습니다.

### 클래스 템플릿
클래스 템플릿은 클래스를 템플릿화 시키는 코드입니다.<br>
대표적인 예시로 STL에 vector list등이 클래스 템플릿을 사용하여 구현되었습니다.<br>
클래스 템플릿은 고려해야될 사항이 많기 때문에 문단을 나눠서 설명하겠습니다.
#### 클래스
먼저 클래스 자체를 템플릿화 시키는 코드입니다.
```cpp
template<typename T, int size>
class vtclass {
public:
	vtclass(void) :
		m_vt(new T[size]),
		m_size(size) {
	}
	~vtclass(void) {
		delete[] m_vt;
	}
private:
	T* m_vt;
	int m_size;
};
void main(void) {
	vtclass<int, 10> vtc; //암시적 템플릿 허용하지 않음 꼭 <형식, 값> 사용할 것
	return 0;
}
```
함수랑 크게 다를것이 없이 클래스 앞에 템플릿 키워드를 사용하면 됩니다.<br>
한 가지 다른점이 함수랑 다르게 암시적 템플릿을 허용하지 않습니다. 꼭 <형식, 값>을 붙여 명시적으로 알려주어야 합니다. 
#### 맴버 함수
맴버 함수 또한 클래스를 템플릿화 시킨 키워드를 사용할 수 있습니다.
```cpp
template<typename T, int size> //이 템플릿을 멤버 함수도 사용할 수 있습니다.
class vtclass {
	...
public:
	T& operator[](size_t size) { //멤버 함수 템플릿!
		return m_vt[size];
	}
	...
};
```
이렇게 함수가 클래스 내부에 있는경우 문제 없지만 함수의 외부에 있는 경우 템플릿을 작성해 줘야합니다.
```cpp
template<typename T, int size>
class vtclass {
	...
public:
	T& operator[](size_t size); //선언부 입니다.
	...
};
template<typename T, int size> //한번 더 써줘야합니다.
T& vtclass<T, size>::operator[](size_t size) { //구현부 입니다. <T, size>도 필수입니다.
	return m_vt[size];
}
```
#### 중첩 클래스 템플릿
```cpp
template<typename T, int>
class otclass {
};
template<template<typename, int> class otclass>
class vtclass {
private:
	otclass<T, 10> otc;
};
void main(void) {
	vtclass<otclass> vtc;
}
```
> ## 특수화

  
> ## 복잡

### 템플릿 형식 매개 변수로서의 함수 포인터
아래코드는 함수 템플릿 포인터를 형식 매개 변수로 받는 함수 템플릿입니다.
쉽게 설명해 함수 포인터를 템플릿이 형식 매개 변수로서 받고있는데
함수 포인터에 들어가는 함수가 함수 템플릿인 경우입니다.
```cpp
template <typename T>
T square_num(const T& t) {
	return t * t;
}
template <typename T, typename U>
T calc_num(const T& t, const U& u) {
	return u(t);
}
void main(void) {
	std::cout << calc_num<int, int (*)(const int&)>(10, &square_num<int>) << std::endl;
}
```
위와 같은 상황은 calc_num 함수와 square_num 함수의 템플릿 인스턴스를 먼저 진행한 후 판단해야합니다.
- sqare_num 함수의 템플릿 인스턴스화 되어 sqare_num<int> 함수가 생성되었고 따로
- calc_num 함수또한 calc_num<int (*)(const int&)> 템플릿 인스턴스가 생성되었다고 봐야합니다.

그 이후 calc_num함수의 매개변수로 10과 sqare_num의 함수 포인터가 들어갔습니다.
### 템플릿 형식 매개 변수로서의 템플릿
클래스 템플릿을 형식 매개 변수로 받는 클래스 템플릿 입니다.
클래스 템플릿을 생성하려 하는데 그안에 다른 클래스 템플릿을 요구하는 클래스가 들어있는 것입니다.
```cpp
template<typename T>
class otclass {
};
template<typename T, template<typename> typename otclass>
class vtclass {
private:
	otclass<T> otc;
};
void main(void) {
	vtclass<int, otclass> vtc;
}
```
이러한 경우 템플릿 인스턴스의 진행에 순서가 정해져 있다고 보는 것이 편합니다.
  1. 먼저 클래스 템플릿을
