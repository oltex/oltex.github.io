---
title: "const"
categories:
  - cpp
tags:
  - tag
---

## 1.개요
const는 객체 또는 변수를 값을 변경할 수 없도록 상수화 시키는 키워드 입니다.<br>
상수 선언은 다음과 같습니다.
```cpp
const int iValue = 10;
```
## 2.선언
const 키워드는 변수뿐 아니라 다른 몇가지 경우에도 적용시킬수 있습니다.<br>
변수를 포함하여 const 키워드를 사용하는 경우는 다음과 같습니다.

### 변수
```cpp
const int iValue = 10;
int const iValue = 10;

iValue = 20; //에러! 값을 변경할 수 없습니다.
```
상수를 선언할 때는 선언과 동시에 반드시 초기화를 해줘야 합니다.<br>
이 후 대입으로 값을 변경시킬수 없습니다.

### 클래스
클래스 내에 상수를 정의 하는 경우, 즉 상수의 유효범위를 클래스 내로 한정하고자 할 때는<br>
const 키워드만 붙이면 끝이지만, 그 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 정적(static) 맴버로 만들어야 합니다.
```cpp
class GamePlayer {
private:
	static const int NumTurns = 5;
};
```
클래스 상수 또한 선언과 동시에 초기화가 가능하지만,<br>
간혹 클래스 상수의 주소를 구한다던지 구식 컴파일러로 인해 정의부를 요구한다던지 한다면 선언부와 정의부를 떨어트려 놓아야 합니다.
```cpp
//GamePlay.h
class GamePlayer {
private:
	static const int NumTurns;
};

//GamePlay.cpp
const int GamePlay::NumTurns = 5;
```

### 함수
기본적으로 함수의 반환값과 매개변수에 const를 사용할 수 있습니다.
그 외에 함수가 클래스 맴버 함수인 경우 선언에 const를 붙일 수 있습니다. 
상수 맴버 함수가 제한하는 부분은 여러가지가 있는데
 1. 함수의 내부에서 해당 함수가 속한 객체의 멤버 변수를 변경할 수 없다.
 1. const가 붙지않은 다른 맴버 함수의 호출을 할 수 없다.
 1. 함수의 반환타입으로 const가 붙지않으면 맴버 변수의 주소 반환을 허용하지 않는다.
  (단 맴버 변수 포인터의 복제가 가능합니다. 이는 비트수준 상수성의 문제로
  이를 통해 배열이나 포인터 내부의 값이 변하는 문제가 발생할 수 있습니다.)

### 포인터
포인터와 상수는 일반적인 변수와 다르게 작동하는 부분이 있습니다.<br>
const 키워드가 어디에 붙냐에 따라 적용되는 상수의 성질이 달라집니다.

포인터와 상수의 관계에 따라 불리는 명칭이 다른데 크게<br>
- 상수 포인터(Constant Pointer),
- 포인터 상수, 상수 지시 포인터(Pointer to Constant),
- 상수 지시 상수 포인터(Constant Pointer to Constant)<br>

라 불리는 방식이 있습니다.<br>

(햇갈린다)<br>
한국어 번역의 차이라고 생각이 드는데 용어가 햇갈리기 쉬우니<br>
아래 표로 정리하겠습니다.

#### 상수 포인터(Constant Pointer)
포인터 그 자체가 상수인 경우를 의미합니다. 포인터의 변수 값은 변경 가능하지만<br>
포인터를 다른 포인터로 변경은 불가능합니다.
```cpp
int* const pPtr = &iValue; //초기화 필수입니다.
```
포인터 상수는 선언과 동시에 초기화를 해줘야하는 문법입니다.<br>
```cpp
int iA = 10;
int iB = 20;
int* const pPtr = &iA;

*pPtr = 30; //포인터의 변수값 변경은 가능합니다.
pPtr = &iB; //에러! 주소값을 변경할 수 없습니다.
```

#### 포인터 상수, 상수 지시 포인터(Pointer to Constant)
포인터가 가리키는 변수를 상수화 하고싶을 경우 포인터 상수를 사용합니다.
```cpp
const int* pPtr = &iValue; //초기화 안해줘도 된다.
int const* pPtr;
```
포인터 상수는 선언과 동시에 초기화 해줄 필요가 없습니다.<br>
가리키는 변수를 상수화 할 뿐 포인터 자체는 상수가 아니기 때문입니다.
```cpp
int iA = 10;
int iB = 20;
const int* pPtr = &iA;
  
*pPtr = 30; //에러! 변수값을 변경할 수 없습니다.
pPtr = &iB; //포인터의 주소값 변경은 가능합니다.
```

#### 상수 지시 상수 포인터(Constant Pointer to Constant)
위 두가지 제한을 모두 가진 포인터 입니다.<br>
변수의 값도 변경할 수 없고 주소값도 변경할 수 없습니다.
```cpp
const int* const pPtr = &iValue;
int const* const pPtr = &iValue;
```
마찬가지로 선언과 동시에 초기화를 해줘야하는 문법입니다.<br>
```cpp
int iA = 10;
int iB = 20;
const int* const pPtr = &iA;

*pPtr = 30; //에러! 변수값을 변경할 수 없습니다.
pPtr = &iB; //에러! 주소값을 변경할 수 없습니다.
```

#### 포인터와 상수의 관계
```cpp
char arrGreeting[] = "Hellow";

char* const pPtr = arrGreeting;       //상수 포인터,   Constant Pointer             상수 포인터
                                      //비상수 데이터
const char* pPtr = arrGreeting;       //비상수 포인터, Pointer to Constant          포인터 상수
                                      //상수 데이터                                 상수 지시 포인터
const char* const pPtr = arrGreeting; //상수 포인터,   Constant Pointer to Constant 상수 지시 상수 포인터
                                      //상수 데이터
```

