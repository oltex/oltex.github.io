---
title: "반복자(Iterator)"
categories:
  - design pattern
tags:
  - tag
---
> ## 개요

행동 디자인 패턴중 하나인 반복자 패턴입니다.<br>
어떤  집합 객체에 대해 내부를 노출하지 않고 속한 원소들을 접근할 수 있는 방법을 제공합니다.<br>
<br>
리스트, 스택, 트리 등을 노출하지 않고 하나씩 순회할 수 있도록 합니다.
> ## 필요성

자료를 보관하기 위해 보통 리스트, 스택, 트리 같은 컬렉션을 사용하는 것이 보편적입니다.<br>
사용자가 자료를 사용하기 위해서는 요소들에게 접근할 수 있는 방법들을 제공해야 합니다.<br>
<br>
접근 방법으로 순차 탐색등 여러가지 존재 할 수 있지만,<br>
때에 따라서 그 방식을 달리하고 싶다고 합니다.<br>
순차, 깊이 탐색등이나, 혹은 어떤 필터를 적용하여 걸러진 데이터만 탐색 하고싶다고 합니다.<br>
<br>
허나 이런 방식의 탐색을 컬렉션에 집어넣는다는 것은<br>
컬렉션의 정체성이 모호해지는 결과를 초래합니다.<br>
<br>
반면 클라이언트 코드는 컬렉션의 저장요소에 관심있을 뿐<br>
컬렉션의 탐색에 관심을 두지 않습니다.
> ## 구현

반복자 패턴은 컬렉션과 클라이언트 코드와 별도의 객체로 분리하여<br>
컬렉션을 탐색하는 방법을 제공합니다.<br>
<br>
예시로 컬렉션을 사용하여 숫자를 저장하고 이를 순회하는 코드입니다.<br>
<br>
먼저 List객체를 만들어 데이터를 저장하고<br>
Iterator 인터페이스 클래스를 제작합니다.<br>
그 다음 첫번째 원소부터 순회하는 FirstIterator객체를 만들어 List객체를 연결시킨 후<br>
순회를 시작합니다.<br>
(코드를 간결히 하기위해 소멸자와 delete를 적지 않았습니다.)
```cpp
struct Node final { //자료를 저장할 노드 구조체입니다.
	Node(int value) :
		_value(value) {
	}
	int _value = 0;
	Node* _prev = nullptr;
	Node* _next = nullptr;
};
```
```cpp
class List final { //양방향 연결 리스트 입니다.
public:
	void Add(Node* node) { //노드를 맨 뒤에 추가하는 함수입니다.
		if (nullptr == _head) {
			_head = node;
			_tail = node;
		}
		else {
			node->_prev = _tail;
			_tail->_next = node;
			_tail = node;
		}
		++_size;
	}
	Node* Head(void) { //리스트의 첫번째 원소를 반환합니다.
		return _head;
	}
	Node* Tail(void) { //리스트의 마지막 원소를 반환합니다.
		return _tail;
	}
	int Size(void) {
		return _size;
	}
private:
	Node* _head = nullptr;
	Node* _tail = nullptr;
	int _size = 0;
};
```
```cpp
class Iterator abstract { //반복자 인터페이스 입니다.
public:
	virtual int Get(void) = 0;
	virtual void Next(void) = 0;
	virtual bool End(void) = 0;
};
class HeadIterator final : public Iterator { //머리부터 순회할 반복자입니다.
public:
	HeadIterator(List* list) :
		_list(list) {
	}
	virtual int Get(void) override { //리스트로부터 머리를 받아와 인덱스만큼 추적하여 반환합니다.
		Node* node = (*_list).Head();
		for (int i = 0; i < _index; ++i)
			node = node->_next;
		return node->_value;
	}
	virtual void Next(void) override { //인덱스를 증가시킵니다.
		++_index;
	};
	virtual bool End(void) override { //현재 인덱스가 리스트의 사이즈를 벗어낫는지 확인합니다.
		if (_list->Size() <= _index)
			return false;
		return true;
	};
private:
	List* _list = nullptr;
	int _index = 0;
};
```
```cpp
void main(void) {
	List* list = new List{ };
	list->Add(new Node{ 0 });
	list->Add(new Node{ 1 });
	list->Add(new Node{ 2 });
	list->Add(new Node{ 3 });
	list->Add(new Node{ 4 });

	Iterator* headIterator = new HeadIterator(list);
	while (headIterator->End()) {
		std::cout << headIterator->Get() << std::endl;
		headIterator->Next();
	}
};
```
원래 
> ## 추가
반복자는 외부 반복자와 내부 반복자로 나뉩니다.


