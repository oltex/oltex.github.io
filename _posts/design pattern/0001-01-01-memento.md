---
title: "메멘토(Memento)"
categories:
  - design pattern
tags:
  - tag
---
> ## 개요

행동 디자인 패턴중 하나인 메멘토 패턴입니다.<br>
객체의 세부 사항을 공개하지 않으면서 해당 객체의 이전 상태를 저장하고 복구할 수 있게 만듭니다.<br>
<br>
객체의 내부 상태를 기록해 둘 필요가 있는 경우가 있습니다.<br>
체크 포인트를 구현한다던가 오류를 복구하는 기능등에 해당합니다.<br>
<br>
이러한 복구기능을 구현하기 위해서는 객체의 내부 상태를 기록하는 과정이 필요합니다.<br>
허나 이는 캡슐화에 위배 될 수 있습니다.
> ## 예시

게임 내에 체크 포인트를 만들었다고 합니다.<br>
체크 포인트는 활성화 시 체크 포인트를 저장 했던 시점으로 모든 상태를 되돌리는 역할을 수행합니다.<br>
<br>
객체는 Monster가 존재하고 몬스터는 Hp를 가지고있습니다.<br>
체크 포인트에는 Save기능과 Load기능이 존재합니다.<br>
<br>
객체의 캡슐화에 위배되지 않으면서 안전하게 정보를 저장하여야 합니다.<br>
이 때 메멘토 패턴을 사용하면 보다 안전하게 체크 포인트를 구현할 수 있습니다.
> ## 구조

메멘토 패턴에는 3가지 개념이 자리잡고 있습니다.
- Originator: 저장 해야 될 객체에 해당합니다.
- Memento: 저장 될 객체의 정보를 담는 클래스 입니다.
- Caretaker: Memento의 보관을 담당합니다. 추가, 반환등의 관리를 맏습니다.

메멘토 패턴은 객체의 캡슐화를 지키기 위해 제약 사항이 존재합니다.<br>
<br>
1.Originator<br>
Memento의 접근 권한은 오로지 Originator만 가지고 있어야 합니다.<br>
따라서 Originator만이 Memento를 생성 할 수 있는 함수를 가지고 있습니다.<br>
또한 Originator만이 Memento를 사용하여 복구 할 수 있는 함수를 가지고 있습니다.<br>
<br>
2.Memento<br>
Memento 클래스와 상호작용 하는 클래스는 딱 2개 뿐입니다. (Originator, Caretaker)<br>
허나 Memento 클래스는 두 클래스에게 각각 허용해야될 인터페이스의 범위가 다릅니다.<br>
따라서 인터페이스를 제한 범위/광범위 인터페이스로 나눕니다.<br>
제한 범위 인터페이스는 Caretaker에게 보이고,(추가로 다른 모든 클래스에게 보입니다.)<br>
광범위 인터페이스는 Originator에게만 보입니다.(이를 위해 friend 키워드를 사용합니다.)<br>
<br>
3.Caretaker<br>
보관자 클래스는 Memento의 보관만을 담당합니다.<br>
Memento의 내용을 건드리지 않습니다.

> ## 구현

체크 포인트에 대한 예시를 구현해보겠습니다.
```cpp
class Memento final {
public:
	//광범위 인터페이스는 여기에 표시합니다.
private:
	friend class Monster; //제한 범위 인터페이스 입니다. 
	Memento(int hp) : //이곳은 Monster 클래스밖에 볼 수 없습니다.
		_hp(hp) {
	}
	int Get(void) {
		return _hp;
	}
private:
	int _hp = 0;
};
```
```cpp
class Monster final {
public:
	Monster(int hp) :
		_hp(hp) {
	}
	Memento* CreateMemento(void) { //Memento를 생성하는 함수
		return new Memento{ _hp };
	};
	void RestoreMemento(Memento* memento) { //Memento로 복구하는 함수
		_hp = memento->Get();
	};
private:
	int _hp = 0;
};
```
```cpp
class Caretaker final { //메멘토의 보관자입니다.
public:
	void Save(Monster* monster) { //몬스터를 받아서 메멘토를 생성해 보관합니다.
		_memento = monster->CreateMemento();
	}
	void Load(Monster* monster) { //몬스터를 받아서 메멘토로 복구합니다.
		monster->RestoreMemento(_memento);
	}
private:
	Memento* _memento = nullptr; //보관자는 메멘토의 공통된 인터페이스 외에는 접근 불가
};
```
```cpp
void main(void) {
	Caretaker* caretaker = new Caretaker;
	Monster* monster = new Monster{ 10 };

	caretaker->Save(monster); //체크 포인트를 세이브합니다.
	//게임 진행중...
	caretaker->Load(monster); //체크 포인트를 로드합니다.
};

```
