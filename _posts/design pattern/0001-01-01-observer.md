---
title: "관찰자(Observer)"
categories:
  - design pattern
tags:
  - tag
---
> ## 개요

행동 디자인 패턴중 하나인 관찰자(감시자) 패턴입니다.<br>
어떤 객체의 상태가 변할 때, 그 객체에 의존성을 지닌 다른 객체들이 결합도를 높이지 않고<br>
그 변화를 통지받을 수 있게 해줍니다.<br>
<br>
객체에 이벤트가 발생했을 때 이를 알릴 수 있는 구독 장치를 정의합니다.<br>

> ## 필요성

객체는 다른 객체와 관련되야 하는 경우가 있습니다.<br>
<br>
게임에 업적을 예로 들어 보겠습니다.<br>
게임이 커질수록 업적의 종류는 다양해지기 마련입니다.<br>
<br>
무가를 처음으로 장착 했다던가, 가로등에 불을 붙였다던가,<br>
단단한 바위를 부쉈다던가 하는 종류가 있을 수 있습니다.<br>
<br>
허나 이러한 업적 클래스를 제작하고 난 후<br>
플레이어 클래스나 오브젝트 클래스에게 이런 업적 클래스를 결합시키려한다면<br>
많은 클래스들과 업적 클래스가 의존관계를 생성할 것입니다.
```cpp
class Achievements final { //업적 클래스
public:
	void EquipWeapon(void) {
		std::cout << "무기를 장착하다" << std::endl;
	}
	void BreakRock(void) {
		std::cout << "바위를 부수다" << std::endl;
	}
};
```
```cpp
class Player final { //플레이어 클래스
public:
	void Equip(void) {
		_achievements->EquipWeapon();
	}
private:
	Achievements* _achievements = nullptr; //업적 클래스와 결합
};
```
```cpp
class Rock final { //바위 클래스
	void Break(void) {
		_achievements->BreakRock();
	}
private:
	Achievements* _achievements = nullptr; //업적 클래스와 결합
};
```

위 예시가 관찰하고 싶어하는 대상 하나가 많은 객체들과 의존 관계가 생성되었다면
이번에는 관찰 당하는 객체 하나가 많은 관찰자들과 의존관계가 형성되는 구조입니다.


> ## 구현

이러한 의존관계를 형성하지 않고 
클래스들간의 상호작용을 위해서 관찰자 패턴을 사용할 수 있습니다.

관찰자 패턴은 다음과 같은 구조를 가집니다.
- Subject: 이벤트를 발생시켜야 하는 주체입니다. 위 예시에서 Player나 Rock를 예로 들 수 있습니다.
- Observer: 이벤트를 알고 싶어하는 객체입니다. 업적 클래스를 예로 들 수 있습니다.

두 가지 구조는 인터페이스 입니다. 추상 클래스로 구성되며
서브 클래스로 내려갑니다.


관찰자 패턴은 서로 연관없는 클래스들이 서로 의존되지 않게 하면서
상호작용 하게 만들기 위한 패턴입니다.

따라서 하나의 기능을 구현하기 위한 클래스들 안에서는
관찰자 패턴은 그다지 유용하지 못합니다.
