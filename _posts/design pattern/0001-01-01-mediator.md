---
title: "중재자(Mediator)"
categories:
  - design pattern
tags:
  - tag
---
> ## 개요

행동 디자인 패턴중 하나인 중재자 패턴입니다.<br>
한 집합에 속해있는 객체의 상호작용을 캡슐화하는 객체를 정의합니다.<br>
<br>
객체들간의 직접적인 통신을 제한하고 중재자를 통해 통신함으로써 의존성을 줄입니다.<br>

객체들끼리 복잡한 상호작용을 가질 때, 혹은
한 객체가 다른 객체를 너무 많이 참조할 때 사용합니다.

또는 여러 클래스에 분산된 행동들이 하나의 상황에 맞게 돌아가야할 때 사용합니다.
> ## 필요성

게임을 구현하고 있습니다.
Dungeon클래스를 만들고 그안에 소환할 수 있는 몬스터를 만들기 위해 Monster클래스를 생성하였습니다.
또 던전안에는 여러 장치가 존재해야하 하기 때문에 Gimmick클래스를 만들었습니다.

상황은 다음과 같습니다.
1.
플레이어가 던전을 돌면서 몬스터를 잡았다고 합니다.
몬스터가 한마리 죽어갈 때마다 남은 몬스터들은 강화됩니다.
또 던전에서 소환되는 몬스터의 주기가 빨라져야 하고 장치는 더 어려워 져야 한다고 합니다.
2.
이번에는 장치를 성공적으로 해제시켰다고 합니다.
이때는 몬스터가 약화돼야 하며 던전에서 소환되는 몬스터의 주기가 느려집니다.
```cpp
class Dungeon final {
public:
	void Spawn(int i) {
		//스폰 속도가 i만큼 증가합니다.
	};
};
```
```cpp
class Gimmick final {
public:
	void Level(int i) {
		//난이도가 i만큼 증가합니다.
	}
	void Clear(void) {
		_dungeon->Spawn(-1);
		for (auto iter : _monsters) {
			iter->Power(-1);
		}
	}
private:
	Dungeon* _dungeon = nullptr; //의존 관계가 형성되었습니다.
	std::vector<Monster*> _monsters;
};
```
```cpp
class Monster final {
public:
	void Power(int i) {
		//파워가 i만큼 증가합니다.
	}
	void Die(void) {
		_dungeon->Spawn(1);
		_gimmick->Level(1);
		for (auto iter : _monsters)
			iter->Power(1);
	}
private:
	Dungeon* _dungeon = nullptr; //의존 관계가 형성되었습니다.
	Gimmick* _gimmick = nullptr;
	std::vector<Monster*> _monsters;
};
```

이렇게 각 객체들간의 관계가 복잡해진다면
중재자 패턴을 고려해 볼 수 있습니다.

