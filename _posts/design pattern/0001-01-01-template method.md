---
title: "템플릿 메서드(Template Method)"
categories:
  - design pattern
tags:
  - tag
---
> ## 개요

행동 디자인 패턴중 하나인 템플릿 메서드 패턴입니다.<br>
부모 클래스는 연산/행동에 해당하는 함수만을 정의하고, 각 함수에서 수행할 처리는 서브 클래스에게 맏깁니다.<br>
<br>
부모 클래스가 맡은 행동 구조는 변경하지 않고,<br>
서브 클래스들이 행동의 특정 단계만을 재정의 할 수 있게 만듭니다.<br>
<br>
템플릿 메서드는 팩토리 메서드와 동일하게 우선적으로 함수를 의미합니다.<br>
<br>
추가.<br>
템플릿 메서드는 template 키워드를 사용하는 방법이 아닙니다.<br>
대신 템플릿 키워드와 비슷한 의미를 지니고 있습니다.
- 템플릿 키워드: 어떠한 T에 대한 함수나 클래스를 찍어내는 틀
- 템플릿 메서드: 어떠한 행동에 대한 함수를 찍어내는 틀

> ## 필요성

템플릿 메서드는 다음과 같은 상황에서 사용하면 좋습니다.
- 서브 클래스들 사이의 공통적인 부분을 하나의 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때
- 한 행동이 이루는 부분 중 다양해질 수 있는 부분을 서브 클래스에서 정의하도록 할 때

템플릿 메서드 패턴은 전략 패턴과 비슷한 관계가 있기 때문에<br>
전략 패턴에서 사용했던 예시를 사용하겠습니다.<br>
<br>
예시를 간략하게 요약하자면
1. 몬스터(Monster)가 존재합니다.
2. 몬스터의 행동을 위한 알고리즘(Algorithm)이 존재합니다.
3. 같은 몬스터라도 난이도(Level)에 따라 다른 알고리즘을 선택할 수 있게 하고 싶습니다.

전략 패턴의 예를 보면<br>
몬스터의 알고리즘을 상속을 이용해 Easy와 Hard로 서브 클래싱하고<br>
몬스터에게 객체 합성을 사용하여 알고리즘을 선택할 수 있게 만들었습니다.<br>
<br>
전략 패턴을 가져와 보겠습니다.
```cpp
class Algorithm abstract {
public:
	virtual void Action(void) = 0;
};
```
```cpp
class Easy final : public Algorithm {
public:
	virtual void Action(void) override { //일부로 주석을 띄어쓰기 별로 나눴습니다!!!
		//쉬운
		//알고리즘을
		//사용합니다.
	};
};
```
```cpp
class Hard final : public Algorithm {
public:
	virtual void Action(void) override {
		//어려운
		//알고리즘을
		//사용합니다.
	};
};
```
전략 방식도 앞서 말한 문제를 해결하는데 유용하지만,<br>
만약 Easy, Hard의 알고리즘이 일부만 바뀌는 거라면 어떻게 될까요?<br>
주석을 확인해 보시면 두 전략 패턴은 쉬운/어려운 이라는 주석 빼고는 동일함을 확인할 수 있습니다.<br>
즉, 각 알고리즘마다 많은 코드가 중복 되는 것입니다.<br>
<br>
템플릿 메서드는 전략 패턴과 같이 상속과 객체 합성을 이용하는것은 같지만<br>
클래스 단위로 행동을 분리하는 것이 아닌 함수 단위로 행동을 분리합니다.
> ## 구조

템플릿 메서드는 다음과 같은 구조를 지닙니다.
- Abstract: 부모 클래스로 행동에 대한 각 단계별 함수를 정의하고 템플릿 메서드를 선언합니다.
  - step: 정의된 각 단계별 함수입니다. 이는 재정의 될 수 있습니다. 기본 연산을 정의할 수 있습니다.
  - TemplateMethod: 템플릿 메서드 입니다. 정의된 행동(step)을 모아 실행하도록 합니다.
- Concrete: 서브 클래스에서 달라진 행동(step)을 재정의 하도록 합니다.

먼저 템플릿 메서드로 바꾸고싶은 행동을 분석하여 step별로 나눕니다.<br>
이 후 추상 클래스를 만들고 각 step을 함수로 만듭니다.<br>
step함수는 순수 가상 함수여도 되고, 기본 연산을 정의해 놔도 됩니다.<br>
그리고 각 step을 실행하는 TemplateMethod 함수를 만듭니다.<br>
이 함수는 재정의 할 수 없게 비가상 함수 또는 final로 만드는 것도 고려해 볼만 합니다.<br>
마지막으로 자식 클래스를 생성하여 필요한 step을 재정의 합니다.
> ## 구현

앞선 코드를 전략 패턴에서 템플릿 메서드 패턴으로 바꿔 보겠습니다.
```cpp
class Algorithm abstract {
public:
	void TemplateMethod(void) { //템플릿 메서드입니다.
		Step0(); //각 스탭을 호출합니다.
		Step1();
		Step2();
	};
protected: //스탭 함수는 protected범위를 가지는게 좋습니다.
	virtual void Step0(void) = 0; //순수 가상 함수로 지정해도 됩니다.
	virtual void Step1(void) { //가상 함수로 지정해도 됩니다.
		//알고리즘을
	}
	virtual void Step2(void) {
		//사용합니다.
	}
};
```
```cpp
class Easy final : public Algorithm {
protected:
	virtual void Step0(void) override { //스탭0만 재정의 합니다.
		//쉬운
	};
};
```
```cpp
class Hard final : public Algorithm {
protected:
	virtual void Step0(void) override {
		//어려운
	};
};
```
주석이 중복되지 않게 된것을 확인 할 수 있습니다.<br>
코드 중복을 피할 수 있게 되었습니다.
> ## 마무리

### 전략 패턴
그렇다면 정확히 전략 패턴과 템플릿 메서드 패턴의<br>
공통점, 차이점은 어떻게 될까요.<br>
<br>
공통점은 두 패턴다 사용자가 동일한 방식으로 소비한다는 것입니다.<br>
부모 클래스의 포인터를 가지고 서브 클래스를 가리키며 함수를 호출한다는 것입니다.<br>
<br>
차이점은 두 클래스는 사용하는 가치가 다르다는 것을 들 수 있습니다.<br>
템플릿 메서드 패턴은 거의 유사한 알고리즘/행동의 일부를 변경시키고 싶을 때 사용하는 것입니다.<br>
따라서 알고리즘이 유사하지 않거나 선택해야될 행동들이 큰 차이를 보일 경우 사용할 수 없습니다.<br>
<br>
반대로 전략 패턴은 선택해야될 행동들이 큰 차이를 보일 때 의미가 더 깊습니다.<br>
내부 알고리즘 또는 행동을 완전 뒤엎어 버려야지만 다른 전략을 제공할 수 있다면 전략 패턴밖에 선택지가 없습니다.
### 팩토리 메서드
팩토리 메서드는 종종 템플릿 메서드 패턴이라고도 합니다.<br>
팩토리 메서드의 객체의 생성을 step별로 달리 하면서 메소드를 제공해 줄 수도 있기 때문입니다.
