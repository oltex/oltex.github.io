---
title: "퀵 정렬(Quick Sort)"
categories:
  - algorithm
tags:
  - tag
---
> ## 개요

정렬 알고리즘 중 하나인 퀵 정렬입니다.<br>
배열을 분할하는 과정을 거치면서 정렬하는 알고리즘입니다.<br>
<br>
배열의 원소중 피벗(pivot)을 선정하고 피벗을 기준으로 작은 값은 왼쪽<br>
큰 값은 오른쪽으로 오게한 후, 두 배열에게 다시금 같은 동작을 반복합니다.<br>
<br>
퀵 정렬은 분할 정복(divide and conquer)이라는<br>
알고리즘 디자인 기법에 근거하여 만들어진 정렬 방법입니다.<br>
<br>
일반적인 경우 다른O(nlogn)알고리즘에 비해 매우 빠른 속도로 작동합니다.

> ## 과정

퀵 정렬의 과정에 대해 얘기해 보겠습니다.<br>
<br>
같은 분할 정복 알고리즘인 합병 정렬은 먼저 분할을 시도한 후<br>
분할된 값을 합병하는 과정에서 정렬이 이루어집니다.<br>
<br>
허나 퀵 정렬은 합병 정렬이 이루어지는 과정에서<br>
분할하는 과정을 정렬에 사용하는 방식으로 이루어집니다.
### 순서
다음과 같은 배열을 퀵 정렬을 사용해<br>
오름차순으로 정렬을 해보겠습니다.
```
[5 1 3 7 9 2 4 6 8]
```
먼저 배열의 원소중에 피벗(pivot)에 해당될 원소를 구합니다.<br>
여기서는 가장 간단한 방법인 맨앞 원소인 5를 피벗에 사용해 보겠습니다.
```
[(5) 1 3 7 9 2 4 6 8]
```
피벗이 결정되었다면 피벗의 다음 원소인 1과 맨 마지막 원소인 8을<br>
각각 {low}와 {high}로 선택합니다.<br>
여기까지가 퀵 정렬을 위한 준비 과정입니다.
```
[(5) {1} 3 7 9 2 4 6 {8}]
```

---
이제 low와 high를 각각 탐색하는 과정을 시작합니다.<br>
low는 피벗에 해당되는 값보다 큰 경우가 올때까지 ++을 시키고,<br>
high는 피벗에 해당되는 값보다 작은 경우가 올때까지 --를 시킵니다.
```
[(5) 1 3 {7} 9 2 {4} 6 8]
```
이 과정이 끝났다면 각각 low와 high는 7과 4에 멈추게 됩니다.<br>
이제 이 둘을 스왑하는 과정을 거칩니다.
```
[(5) 1 3 {4} 9 2 {7} 6 8]
```
스왑이 완료되었다면 다시금 탐색 과정을 거칩니다.
```
[(5) 1 3 4 {9} {2} 7 6 8]
```
이번에는 9와 2가 low와 high로 선택되게 됩니다.<br>
다시한번 스왑을 해주도록 하겠습니다.
```
[(5) 1 3 4 {2} {9} 7 6 8]
```

---
이제 다시한번 탐색 과정을 거쳐보겠습니다.<br>
이 때 low는 9를 선택하게 될 것이고<br>
high는 2를 선택하게 될 것입니다.<br>
<br>
만약 low와 high의 인덱스가 서로 뒤집어지는 상황이 된다면 (low > high)<br>
모든 원소에 대한 탐색과 스왑을 마친 상태가 됩니다.

> ## 구현


> ## 성능

퀵 정렬의 내부 루프는 컴퓨터 아키텍쳐가 효율적으로 작동하도록 설계되어있습니다.
