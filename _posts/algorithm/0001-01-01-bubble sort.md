---
title: "버블 정렬(Bubble Sort)"
categories:
  - algorithm
tags:
  - tag
---
> ## 개요

정렬 알고리즘중 하나인 버블 정렬입니다.<br>
서로 인접한 두 원소를 검사하여 정렬하는 알고리즘입니다.<br>
<br>
두 원소를 검사하여 정렬 순서에 맞지 않으면 두 원소를 교체하는 과정을 반복하여 정렬합니다.<br>
이 과정이 거품이 수면위로 올라오는 듯한 모습을 보여주기 때문에 버블 정렬이라는 이름이 지어졌습니다.<br>
<br>
정렬 알고리즘 중에 구현이 매우 간단한 편에 속하지만 성능적인 측면에서 좋지 못합니다.<br>
버블 정렬은 O(n^2)의 시간 복잡도를 가지고 있습니다.
> ## 과정

버블 정렬이 이루어지는 과정입니다.<br>
버블 정렬은 첫 원소부터 시작하여 다음 원소와 비교하는 과정을 거칩니다.<br>
다음과 같은 배열에 오름차순 정렬을 진행해 보겠습니다.
```
3 2 4 1
```
위 배열에서는 첫번째 원소인 3과, 두번째 원소인 2를 비교하여<br>
정렬순서에 맞게 두 위치를 바꿔놓습니다.
```
2 3 4 1
```
이 다음 두번째 원소인 3과, 세번째 원소인 4를 비교합니다.<br>
3과 4는 3이 더 작은 값이니 스왑이 이루어지지 않습니다.
```
2 3 4 1
```
이제 마지막으로 세번째 원소인 4와, 네번째 원소인 1을 비교합니다.<br>
4와 1은 4가 더 큰 값이니 스왑이 이루어집니다.
```
2 3 1 4
```
이러한 과정을 거친다면 가장 마지막 원소는 배열의 원소중에서 가장 큰 값을 가진 원소가 됩니다.<br>
정렬해야 되는 원소의 갯수가 총 4개이니 이 과정을 총 4번 반복해 줍니다.(이번 회차 포함)<br>
<br>
그렇게 된다면 4개의 원소가 큰 순서대로 뒤에서 부터 오게될 것입니다.<br>
이는 앞에서 부터 보면 오름차순으로 정렬되어있게 됩니다.<br>
<br>
이를 요약하면 가장 큰 값을 가진 원소를 맨 뒤로 차곡차곡 보내는 작업이<br>
이루어 졌다고 볼 수 있습니다.
> ## 구현

버블 정렬을 코드로 구현해 보겠습니다.
```cpp
void Bubble_Sort(int arr[], int size) {
	for (int i = 0; i < size - 1; ++i)
		for (int j = 0; j < size - i - 1; ++j)
			if (arr[j] > arr[j + 1])
				arr[j] ^= arr[j + 1] ^= arr[j] ^= arr[j + 1]; //스왑 코드
}
```
```cpp
void main(void) {
	int arr[9] = { 3, 2, 4, 1, 5, 7, 0, 9, 8 };
	Bubble_Sort(arr, 9);
	for (auto iter : arr)
		std::cout << iter;
};
```
버블 정렬 함수입니다.<br>
매개 변수로 정렬할 배열인 arr과 그 배열의 사이즈인 size를 받고 있습니다.<br>
<br>
첫번째 for문은 정렬해야되는 원소의 갯수만큼 반복하는 반복문입니다.<br>
n개의 원소의 정렬에는 n-1번의 정렬이 이루어지면 나머지 1개는 자동으로 정렬되기 때문에 size-1의 제한을 둡니다.<br>
<br>
두번째 for문은 모든 원소를 순회하며 두 원소가 스왑해야하는지 검사합니다.<br>
j번째와 j+1번째 원소를 비교하여 정렬 순서에 맞게 스왑합니다.<br>
j가 가장 마지막 원소까지 올라가면 j+1은 마지막 원소를 넘어가게 되니 size-1의 제한을 둡니다.<br>
여기에 추가로 -i의 제한을 두는 이유는<br>
i만큼 배열의 뒷 원소들은 이미 정렬이 완료된 원소들이라 생략하기 위함입니다.
> ## 성능

버블 정렬의 성능에 대해 이야기 하겠습니다.<br>
버블 정렬이 이중 for문으로 구현되어 있기 때문에 시간 복잡도는 O(n^2)이 됩니다.<br>
<br>
정렬 알고리즘은 몇가지 규격이 존재하기 때문에<br>
시간 복잡도만 보는 것이 아닌 비교와 대입 연산의 성능에도 신경을 씁니다.<br>
<br>
버블 정렬의 단점은 비교 연산 뿐만 아니라 대입 연산도 많이 이루어진다는 것입니다.<br>
대입 연산또한 이중 for문을 통해서 O(n^2)만큼 이루어지는 것을 볼 수 있습니다.
