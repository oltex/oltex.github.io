---
title: "버블 정렬(Bubble Sort)"
categories:
  - algorithm
tags:
  - tag
---
> ## 개요

정렬 알고리즘중 하나인 버블 정렬입니다.<br>
서로 인접한 두 원소를 검사하여 정렬하는 알고리즘입니다.<br>
<br>
두 원소를 검사하여 정렬 순서에 맞지 않으면 두 원소를 교체하는 과정을 반복하여 정렬합니다.<br>
이 과정이 거품이 수면위로 올라오는 듯한 모습을 보여주기 때문에 버블 정렬이라는 이름이 지어졌다고 합니다.<br>
<br>
정렬 알고리즘 중에 구현이 매우 간단한 편에 속하지만 성능적인 측면에서 좋지 못합니다.<br>

> ## 복잡도

### 시간 복잡도
버블 정렬은 비교 연산, 이동 연산에 대해서<br>
각각의 시간 복잡도를 계산해 보겠습니다.<br>
<br>
버블 정렬의 비교 연산은 O(n^2)의 시간 복잡도를 가지고 있습니다.<br>
또한 정렬이 완료되었음에도 모든 원소를 탐색하기 때문에<br>
최선, 평균, 최악의 경우에도 같은 O(n^2)의 시간 복잡도를 지닙니다.<br>
<br>
버블 정렬의 이동 연산은 원소가 정렬순서에 맞지 않는 경우 일어납니다.<br>
따라서 최선의 경우 이동 연산이 일어나지 않지만<br>
최악의 경우 이동 연산은 O(n^2)의 시간 복잡도를 지닙니다.
### 공간 복잡도
주어진 배열 안에서 swap을 통해 정렬이 수행되므로 O(n)의 공간 복잡도를 지닙니다.
> ## 과정

버블 정렬이 이루어지는 과정입니다.<br>
버블 정렬은 첫 위치부터 시작하여 다음 위치와 비교하는 과정을 거칩니다.<br>
다음과 같은 배열에 오름차순 정렬을 진행해 보겠습니다.
```
3 2 4 1
```
위 배열에서는 첫번째 원소인 3과, 두번째 원소인 2를 비교하여<br>
정렬순서에 맞게 두 위치를 바꿔놓습니다.
```
2 3 4 1
```
이 다음 두번째 원소인 3과, 세번째 원소인 4를 비교합니다.<br>
3과 4는 3이 더 작은 값이니 스왑이 이루어지지 않습니다.
```
2 3 4 1
```
이제 마지막으로 세번째 원소인 4와, 네번째 원소인 1을 비교합니다.<br>
4와 1은 4가 더 큰 값이니 스왑이 이루어집니다.
```
2 3 1 4
```
이러한 과정을 거친다면 가장 마지막 원소는 배열의 원소중에서 가장 큰 값을 가진 원소가 됩니다.<br>
정렬해야 되는 원소의 갯수가 총 4개이니 이 과정을 총 3번 반복해 줍니다.(이번 회차 포함)<br>
(뒤에 배열는 정렬되어 있으니 남은 배열에 대해서만 탐색하고<br>
첫 원소는 모든 작업이 끝나면 알아서 정렬되니 생략합니다.)<br>
<br>
그렇게 된다면 4개의 원소가 큰 순서대로 뒤에서 부터 오게될 것입니다.<br>
이는 앞에서 부터 보면 오름차순으로 정렬되어있게 됩니다.<br>
<br>
이 과정을 정리하면<br>
1. 남은 배열을 2칸씩 순차적으로 탐색하며
2. 스왑을 통해 그 원소를 유지하면서 따라오게 만들고
3. 그 원소를 맨 뒤로 차곡차곡 보내는 작업을
4. n-1번 반복해서 정렬합니다.

라고 볼 수 있습니다.
> ## 구현

버블 정렬을 코드로 구현해 보겠습니다.<br>
오름차순 정렬을 진행하는 버블 정렬 함수입니다.

```cpp
void Bubble_Sort(int arr[], int size) {
	for (int i = 0; i < size - 1; ++i)
		for (int j = 0; j < size - i - 1; ++j)
			if (arr[j] > arr[j + 1])
				arr[j] ^= arr[j + 1] ^= arr[j] ^= arr[j + 1]; //스왑 코드
}
```
```cpp
void main(void) {
	int arr[9] = { 3, 2, 4, 1, 5, 7, 0, 9, 8 };
	Bubble_Sort(arr, 9);
	for (auto iter : arr)
		std::cout << iter;
};
```
매개 변수로 정렬할 배열인 arr과 그 배열의 사이즈인 size를 받고 있습니다.<br>
<br>
첫번째 for문은 정렬해야되는 원소의 갯수만큼 반복하는 반복문입니다.<br>
n개의 원소의 정렬에는 n-1번의 정렬이 이루어지면 나머지 1개는 자동으로 정렬되기 때문에 size-1의 제한을 둡니다.<br>
<br>
두번째 for문은 모든 원소를 순회하며 두 원소가 스왑해야하는지 검사합니다.<br>
j번째와 j+1번째 원소를 비교하여 정렬 순서에 맞게 스왑합니다.<br>
<br>
j가 가장 마지막 원소까지 올라가면<br>
j+1은 마지막 원소를 넘어가게 되니 size-1의 제한을 둡니다.<br>
<br>
여기에 추가로 -i의 제한을 두는 이유는<br>
i만큼 배열의 뒷 원소들은 이미 정렬이 완료된 원소들이라 생략하기 위함입니다.
