---
title: "빅-오 표기법(Big-Oh Natation)"
categories:
  - design pattern
tags:
  - tag
---
> ## 개요

알고리즘의 효율성을 따지기 위한 표기법으로,
알고리즘의 최악의 경우에 걸리는 시간 복잡도를 수식으로 나타냅니다.

> ## 사전 지식

빅오 표기법을 설명하기 전에
자료구조와 알고리즘에 대한 몇가지 사전적 지식이 필요합니다.

### 자료 구조

프로그래밍을 하는 과정을 한마디로 요약하면
데이터를 저장하고 저장된 데이터를 활용하여 어떤 처리를 하는 것이라고 볼 수 있습니다.

여기서 데이터를 저장하는 과정을
우리는 자료 구조라는 정보의 집합체에 담는 방법을 선택합니다.
```cpp
void main(void) {
	int arr[5]{ 0, 1, 2, 3, 4, 5 };
}
```
배열 자료 구조를 사용하여 int형 데이터를 저장해 보았습니다.

자료 구조에 데이터를 담았다면 이를 처리하는 과정이 필요합니다.
데이터를 처리하는 과정에는 이 자료 구조에 대한 탐색이 동반될 것입니다.
```cpp
void main(void) {
	int arr[5]{ 0, 1, 2, 3, 4, 5 };

	int sum = 0;
	for (int i = 0; i < 5; ++i)
		sum += arr[i];
};
```
for문을 통해 배열에 저장된 모든 값을 더하였습니다.

탐색을 하는 과정을 우리는 탐색 알고리즘이라 부를 수 있습니다.
알고리즘과 자료구조는 떼어질 수 없는 관계를 가집니다.
(배열이 5칸 있고 이들을 순회할 수 있다는 보증이 존재하기 때문에
for문을 사용한 알고리즘으로 작동할 수 있던 것입니다.)

아쉽게도 자료 구조는 배열 한가지만 존재하지 않습니다.
또한 자료 구조가 같다 할지라도, 알고리즘은 방식은 다양할 수 있습니다.

정리해보면 이렇습니다.
- 자료구조에 따라 알고리즘은 달라집니다.
- 알고리즘은 자료구조에 의존적입니다.
- 의존적이라 할지라도 알고리즘은 방식은 여러가지일 수 있습니다.

### 시간 복잡도(time complexity)와 공간복잡도(space complexity)

자료구조가 여러 가지 일 때
그에 맞는 알고리즘을 제대로 채택했다고 가정해보겠습니다.

그러면 그에 맞는(자료 구조에 맞는) 알고리즘이 여러가지 일 때는
무슨 기준으로 알고리즘을 채택해야 할까요?

알고리즘의 최우선 순위는 가장 효율적인 알고리즘을 채택하는 것이라 볼 수 있습니다.
여기서 효율적인 알고리즘을 판단하는 요소로 2가지를 볼 수 있습니다.
- 어떤 알고리즘이 가장 빠르고 또 느린가요?
- 어떤 알고리즘이 메모리를 적게 혹은 많이 쓰나요?

하나는 속도에 관련된것이고 다른 하나는 메모리 사용량에 관련된 것입니다.
이를 이렇게 표현합니다.
- 시간 복잡도: 알고리즘에 들어가는 수행시간 분석 결과
- 공간 복잡도: 알고리즘에 들어가는 메모리 사용량 분석 결과

가장 최선책은 속도도 빠르고 메모리도 적게 쓰는 것이겠지만
두가지가 모두 베스트인 경우는 드뭅니다.

그런데 일반적으로 알고리즘의 효율성을 따질때는 메모리보다는 속도에 초점을 둡니다.
하드웨어가 발전함에 따라 메모리의 여유공간은 점점 커져간것도 있고
사용자는 메모리를 체감하지 못하지만, 속도는 체감하기 때문입니다.

정리하자면 이렇습니다.
- 알고리즘의 가장 중요한 요소는 속도이다.
- 따라서 알고리즘을 선택할 때는 시간 복잡도(속도)를 봐야한다.

### 계산

이제 시간 복잡도가 중요하다는 점을 알았으니
시간 복잡도를 계산하여 가장 효율적인 알고리즘을 채택해야 합니다.

그렇다면 어떻게 계산해야 할까요?
시계를 가져다 두고 일일히 시간을 재고있을수는 없는 노릇일 것입니다.

`그냥 대충좀 넣어보고 빠른거 고르면 안되나요?`
여기서 한가지 더 알고 가야할 사실이 있는데
알고리즘은 처리해야될 데이터의 양에 따라 수행 시간이 변경된다는 것입니다.

이게 무슨소리냐면
데이터가 5개일 때 5초 걸리던 알고리즘이, 데이터가 50개가 되면 500초 걸릴 수도 있고
데이터가 5개일 때 10초 걸리던 알고리즘이, 데이터가 50개가 되면 100초 걸릴 수도 있다는 것입니다.



따라서 알고리즘의 시간 복잡도를 계산하기 위해서 다음과 같은 방식을 취합니다.
- 연산의 횟수를 셉니다.
- 

