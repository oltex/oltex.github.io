---
title: "빅-오 표기법(Big-Oh Natation)"
categories:
  - design pattern
tags:
  - tag
---
> ## 개요

알고리즘의 효율성을 따지기 위한 표기법으로,<br>
알고리즘의 최악의 경우에 걸리는 시간 복잡도를 수식으로 나타냅니다.
> ## 사전 지식(이론)

빅오 표기법을 설명하기 전에<br>
자료구조와 알고리즘에 대한 몇가지 사전적 지식이 필요합니다.
### 자료 구조
프로그래밍을 하는 과정을 한마디로 요약하면<br>
데이터를 저장하고 저장된 데이터를 활용하여 어떤 처리를 하는 것이라고 볼 수 있습니다.<br>
<br>
여기서 데이터를 저장하는 과정을<br>
우리는 자료 구조라는 정보의 집합체에 담는 방법을 선택합니다.
```cpp
void main(void) {
	int arr[5]{ 0, 1, 2, 3, 4, 5 };
}
```
배열 자료 구조를 사용하여 int형 데이터를 저장해 보았습니다.
### 알고리즘
자료 구조에 데이터를 담았다면 이를 처리하는 과정이 필요합니다.<br>
데이터를 처리하는 과정에는 이 자료 구조에 대한 접근이 동반될 것입니다.
```cpp
void main(void) {
	int arr[10]{ 0, 1, 2, 3, 4, 5 };

	int  search = 3;
	for (int i = 0; i < 5; ++i)
		if (search == arr[i]) {
			std::cout << "찾았다!" << std::endl;
			break;
		}
};
```
배열의 인덱스중 3을 찾으면 찾았다라고 외칩니다.<br>
이를 배열에 대한 탐색 알고리즘이라 부릅니다.<br>
<br>
이처럼 알고리즘과 자료구조는 떼어질 수 없는 관계를 가집니다.<br>
배열이라는 자료구조가 결정되어 있어야 순차 탐색이라는 알고리즘을 결정했을 테니까요.<br>
<br>
아쉽게도 자료 구조는 배열 한가지만 존재하지 않습니다.<br>
만약 배열이 아니였다면 탐색 방법은 달라졌어야 합니다.<br>
<br>
또한 자료 구조가 같다 할지라도, 알고리즘은 방식은 다양할 수 있습니다.<br>
위 코드는 순차 탐색이지만 이진 탐색 방식도 고려해 볼 수 있겠죠<br>
아래서 이야기할 내용은 이 탐색 알고리즘들에 관련된 것입니다.<br>
<br>
정리해보면 이렇습니다.
- 자료구조에 따라 알고리즘은 달라집니다.
- 알고리즘은 자료구조에 의존적입니다.
- 의존적이라 할지라도 알고리즘은 방식은 여러가지일 수 있습니다.
- 앞으로의 내용은 전부 탐색 알고리즘에 대한 것입니다.

### 시간 복잡도(time complexity)와 공간복잡도(space complexity)
자료구조가 여러 가지 일 때<br>
그에 맞는 알고리즘을 제대로 채택했다고 가정해보겠습니다.<br>
<br>
그러면 그에 맞는(자료 구조에 맞는) 알고리즘이 여러가지 일 때는<br>
무슨 기준으로 알고리즘을 채택해야 할까요?<br>
<br>
알고리즘의 최우선 순위는 가장 효율적인 알고리즘을 채택하는 것이라 볼 수 있습니다.<br>
여기서 효율적인 알고리즘을 판단하는 요소로 2가지를 볼 수 있습니다.
- 어떤 알고리즘이 가장 빠르고 또 느린가요?
- 어떤 알고리즘이 메모리를 적게 혹은 많이 쓰나요?

하나는 속도에 관련된것이고 다른 하나는 메모리 사용량에 관련된 것입니다.<br>
이를 이렇게 표현합니다.
- 시간 복잡도: 알고리즘에 들어가는 수행시간 분석 결과
- 공간 복잡도: 알고리즘에 들어가는 메모리 사용량 분석 결과

가장 최선책은 속도도 빠르고 메모리도 적게 쓰는 것이겠지만<br>
두가지가 모두 베스트인 경우는 드뭅니다.<br>
<br>
그런데 일반적으로 알고리즘의 효율성을 따질때는 메모리보다는 속도에 초점을 둡니다.<br>
하드웨어가 발전함에 따라 메모리의 여유공간은 점점 커져간것도 있고<br>
사용자는 메모리를 체감하지 못하지만, 속도는 체감하기 때문입니다.<br>
<br>
정리하자면 이렇습니다.
- 알고리즘의 가장 중요한 요소는 속도이다.
- 따라서 알고리즘을 선택할 때는 시간 복잡도(속도)를 봐야한다.

### 시간 복잡도 계산

이제 시간 복잡도가 중요하다는 점을 알았으니<br>
시간 복잡도를 계산하여 가장 효율적인 알고리즘을 채택해야 합니다.<br>
<br>
그렇다면 어떻게 계산해야 할까요?<br>
시계를 가져다 두고 일일히 시간을 재고있을수는 없는 노릇일 것입니다.<br>
<br>
그냥 대충좀 넣어보고 빠른거 고르면 안되나요?<br>
여기서 한가지 더 알고 가야할 사실이 있는데<br>
알고리즘은 처리해야될 데이터의 양에 따라 수행 시간이 변경된다는 것입니다.<br>
<br>
이게 무슨소리냐면
1. 데이터가 50개일 때 5초 걸리던 알고리즘이, 데이터가 500개가 되면 500초 걸릴 수도 있고
2. 데이터가 50개일 때 10초 걸리던 알고리즘이, 데이터가 500개가 되면 100초 걸릴 수도 있다는 것입니다.

이러한 상황에서 시계로 계산하려 들면 몇번의 시간 계산으로 안됩니다.<br>
데이터 양의 변화에 따라 걸리는 시간의 변화를 알아야하는데 이를 위해<br>
수십 수백 수천번을 계산하고 있을 수는 없을 것입니다.<br>
<br>
해결방안을 제시해야될 때가 왔습니다.<br>
알고리즘의 시간 복잡도를 계산하기 위해서 다음과 같은 방식을 취합니다.
- 연산의 횟수를 셉니다.
- 데이터 n개에 대한 연산 횟수를 계산하는 함수 T(n)을 구성합니다.

시간으로 계산하기에는 무리가 있는걸 알았으니까 연산횟수 = 시간이라는 정의를 내립니다.<br>
그리고 데이터 n개에 따른 연산 횟수를 계산하는 함수T(n)를 세워<br>
알고리즘의 빠르기를 판단하는 것입니다.<br>
<br>
이제 데이터의 개수 n을 넣으면 결과로 연산 횟수를 반환하는데 이렇게 하면<br>
데이터의 개수에 따른 연산횟수의 변화 정도를 판단할 수 있습니다.<br>
<br>
마지막으로 한가지가 더 남았는데 바로 n의 개수에 관련된 것입니다.<br>
앞선 예시를 살펴보면 n이 적을때는 1번이, n이 많을때는 2번이 적합한 알고리즘일 것입니다.<br>
<br>
그렇다면 2번이 적합한 알고리즘일까요?<br>
사실 여기에 대한 정답은 없습니다.<br>
상황에 따라 n이 몇개인지 수식은 알 수 없을테니까요.<br>
<br>
하지만 대부분은 n이 많은 경우를 가정합니다.<br>
왜냐면 n이 적을때는 차이가 나더라도 큰 차이인 경우는 대개 없기 때문입니다.<br>
반대로 n이 많다면 차이가 크게 벌어지는 경우는 많습니다.<br>
또한 데이터는 언제든 추가될 수 있다는 점도 가정해야합니다.<br>
<br>
정리해보면 이렇습니다.
- 시간 복잡도는 연산 횟수로 판단할 수 있다고 정의하고.(시간 복잡도 = 연산 횟수)
- 데이터 n개에 따른 연산 횟수를 도출해내는 T(n) 수식을 세운다.
- n의 개수는 사용자의 상황에 따라 정한다. 대부분 n이 많을때를 가정한다.

### 최선의 경우(best case)와 최악의 경우(worst cast)

이제 우리는 효율적인 알고리즘을 선택하는 수식을<br>
생성하여 알고리즘을 판단할 수 있게 되었습니다.<br>
<br>
여기서 다시한번 짚고 넘어가야할 것이 있습니다.<br>
우리가 위에서 얘기했던 모든 알고리즘은 탐색 알고리즘이라는 것이지요.<br>
<br>
위에서 얘기했던 예시를 가져와 보겠습니다.<br>
연산 횟수에 대해 알았으니 연산 횟수로 바꿔보겠습니다.
1. 데이터가 50개일 때 5회 걸리던 알고리즘이, 데이터가 500개가 되면 500회 걸린다.
2. 데이터가 50개일 때 10회 걸리던 알고리즘이, 데이터가 500개가 되면 100회 걸린다.

의문을 하나 가져봅시다.<br>
1번 방식을 사용했을 때 데이터가 500개인 경우라도<br>
내가 찾고싶어하는 데이터가 단박에 나왔으면 1회 아닐까요?<br>
500회라는 연산 횟수은 어떻게 측정된 것일까요?<br>
<br>
사실 시간복잡도 계산을 설명하던 와중에 저것을 설명하기에는<br>
글이 너무 복잡해지기 때문에 뒤로 미뤄두었습니다.<br>
<br>
탐색 알고리즘의 경우
- 운이 좋아서 탐색할 대상이 바로 등장하는 경우가 있고
- 운이 없어서 탐색할 대상이 탐색 알고리즘의 맨 뒤에 존재하거나 아예 없는 경우도 있을 것입니다.

이러한 경우를 최선의 경우와 최악의 경우라 부릅니다.<br>
<br>
알고리즘의 효율성을 계산하는데 있어서 최선의 경우는 고려하지 않습니다.<br>
왜냐면 최선의 경우에는 대게 만족할만한 결과를 보여주기 때문이지요.<br>
반면 알고리즘의 최악의 경우에는 알고리즘 별로 성능에 큰 차이를 보이는 경우가 많습니다.<br>
<br>
따라서 위 예시의 500회라는 연산 횟수는 최악의 경우를 계산한 것입니다.<br>
데이터의 개수 n개를 많은 경우로 가정하는 것과 같은 이치입니다.<br>
<br>
정리하자면 이렇습니다.
- 알고리즘은 최악의 경우를 가정합니다.

> ## 사전 지식(실전)

우리가 해야될 일을 실전으로 옮겨봐야 겠습니다.
- 데이터 n개에 대한
- 최악의 경우의 연산 횟수를
- 계산할 수 있는 수식으로 나타낸다.
