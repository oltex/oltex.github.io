---
title: "빅-오 표기법(Big-Oh Natation)"
categories:
  - algorithm
tags:
  - tag
---
> ## 개요

알고리즘의 효율성을 따지기 위한 표기법으로,<br>
시간 복잡도를 점근 표기법으로 나타냅니다.
> ## 사전 지식

### 시간 복잡도
빅오 표기법을 설명하기 위해서는<br>
시간 복잡도에 대한 사전 지식이 필요합니다.

### 점근 표기법(asymptotic notation)
개요에서 설명하기를<br>
시간 복잡도를 점근 표기법 나타내는 방법이라고 하였습니다.<br>
<br>
먼저 점근적이라는 뜻을 알아보겠습니다.<br>
<br>
사전적 의미로 점근이란 점점 가까워짐을 의미하는 말입니다.<br>
그렇다면 무엇에 가까워 짐을 의미하는 것일까요.<br>
수학적 의미로 점근이란 변수 또는 함수가 한계치(보통 무한대)에 가까워짐을 의미합니다.<br>
그리고 그에 따른 값에 접근한다는 의미이기도 합니다.<br>
<br>
점근 표기법은 이러한 점근의 특성을 이용합니다.<br>
시간 복잡도 함수를 무한대로 보내서 표기하겠다.는 뜻을 의미합니다.<br>
<br>
이를 수학적 언어로 표현하면<br>
시간복잡도를 근사치(approximation)로 표현하겠다. 라는 뜻이 됩니다.<br>
<br>
이러한 점근 표기법을 사용하는 이유는<br>
함수가 있을때, 보다 간단한 함수로 만들어 표시하기 위함입니다.<br>
<br>
이러한 점근 표기법에는 여러가지가 존재합니다.<br>
그중 가장 많이쓰이고 있는 빅오 표기법에 대해 설명하겠습니다.
> ## 설명

이러한 시간 복잡도 함수가 존재한다고 가정해보겠습니다.
```
T(n) = n^2 + 2n + 1
```
사실 시간 복잡도 함수는 정확히 구하는 과정이 녹록지 않습니다.<br>
따라서 다음과 같은 고민을 할 수 있습니다.<br>
<br>
이 시간 복잡도 함수는 n^2 + 2n + 1 아니면 n^2 + n + 1일텐데...<br>
이러한 고민을 빅오 표기법을 통해 해결해 보겠습니다.

### 빅오 표기법(점근)
빅오 표기법은 함수에서 가장 영향력이 큰 부분을 표기하는 방식입니다.<br>
영어로 얘기하자면 Big O 즉 가장 큰 O를 따지는 것입니다. (여기서 O는 영향력을 의미합니다.)<br>
<br>
시간 복잡도에서 차지하는 가장 영향력이 큰 부분을 제외한 모든 부분을 날려버립니다.<br>
한번 T(n) = n^2 + 2n + 1에서 각 부분이 차지하는 비율을 확인해 보겠습니다.

n|n^2|2n|1|n^2의 비율
---|---|---|---|---
10|100|20|1|82.64%
100|10000|200|1|98.03%
1000|1000000|2000|1|99.80%

n이 조금만 증가하여도 n^2가 차지하는 비율이 98%를 넘어서는 모습을 확인할 수 있습니다.<br>
n이 증가할 수록 2n + 1가 미치는 영향은 미미해집니다.<br>
따라서 다음과 같이 간략화 할 수 있습니다.
```
T(n) = n^2
```
이를 빅오 표기법으로 표시하면 이렇습니다.
```
O(n^2)
```
### 빅오 표기법(증감)

이제 가장 영향력이 큰 부분을 찾는 것까진 알았습니다.<br>
다음과 같은 시간 복잡도가 있을 때 빅오 표기법은 어떻게 될까요?
```
T(n) = n^2 + 2n + 1

T(n) = 100n^2 + 2n + 1
```
두 시간 복잡도의 빅오 표기법은 다음과 같습니다.
```
O(n^2)

O(n^2)
```
빅오 표기법은 가장 영향력이 큰 부분만 남기는 것은 알고있는데<br>
이번엔 가장 영향력이 큰 부분 중에서 100또한 제거됐습니다. 100은 왜 제거됐을까요?<br>
<br>
이는 빅오 표기법의 또다른 의미에서 찾아볼 수 있습니다.<br>
빅오 표기법은 데이터 수의 증가에 따른 연산 횟수의 증감 형태를 나타내는 표기법이기도 합니다.<br>
<br>
즉 빅오의 관점에서 두 함수는 동일하다고 볼 수 있습니다.
- 데이터 수가 2, 3, 4개로 늘어날 때마다 연산횟수는 4, 8, 16으로 두 배씩 늘어났습니다.
- 데이터 수가 2, 3, 4개로 늘어날 때마다 연산횟수는 99, 198, 396으로 두 배씩 늘어났습니다.

결국 빅오를 이해하는 방향은<br>
함수의 증감 추세를 보기 위한 표기법이라는 것입니다.<br>
<br>
따라서 다음이 의미하는 바는
```
O(log n)
```
데이터 수의 증가에 따른 연산 횟수의 증가 형태를 좌표평면상에 그려놓으면<br>
증가하는 추세가 둔화되는 형태를 띤다. 즉 로그 그래프와 유사한 형태를 띤다.<br>
<br>
라고 이해하는 것이 옳습니다.
> ## 예시

빅오 표기법에 대해 정리하자면
- 시간 복잡도에서 가장 영향력 있는 부분만 남기면서
- 데이터에 따른 연산 횟수의 증감 형태만을 남기는 표기법

이라고 정리할 수 있습니다.<br>
<br>
빅오 표기법은 이러한 특성 때문에 대표적인(흔히 쓰이는) 표기가 존재합니다.<br>
대표적인 표기들은 다음과 같습니다.
- O(1)<br>
상수형 빅오라고 부릅니다.<br>
데이터 수에 상관 없이 항상 연산 횟수가 고정인 알고리즘을 뜻합니다.<br>
연산 횟수가 3회 진행되는 알고리즘이라도 O(1)이라 표기합니다.<br>
연산횟수가 고정인 알고리즘을 대표한다는 의미가 있습니다.
- O(log n)<br>
로그형 빅오라고 부릅니다.<br>
데이터 수의 증가율에 비해서 연산 횟수의 증가율이 훨씬 낮은 알고리즘을 의미합니다.<br>
따라서 매우 바람직한 유형입니다. 로그의 밑이 얼마냐에 따라서 차이가 나긴 하지만<br>
성능 관점에서 미미하기 떄문에 대부분의 경우 무시됩니다.
- O(n)<br>
선형 빅오라고 부릅니다.<br>
데이터의 수와 연산 횟수가 비례하는 알고리즘을 의미합니다.
- O(n log n)<br>
선형 로그형 빅오라고 부릅니다.<br>
데이터의 수가 두 배로 늘 때, 연산 횟수는 두 배를 조금 넘게 증가하는 알고리즘을 의미합니다.<br>
선형 빅오 * 로그형 빅오의 형태입니다. 알고리즘 중에는 이에 해당하는 알고리즘이 적지 않습니다.
- O(n^2)<br>
데이터의 수가 증가율에 제곱에 해당하는 연산 횟수를 요구하는 알고리즘을 의미합니다.<br>
데이터의 양이 많은 경우 적용하기 부적절합니다. 이는 이중 중첩 반복문 내에서 발생합니다.<br>
그리 바람직 하지 못한 경우라고 볼 수 있습니다.<br>
지수가 증가할 때마다 3중 4중 중첩문에 해당하는 연산을 요구하게 되는데<br>
이정도 되면 그냥 적용하기에는 무리가 있는 알고리즘이 됩니다.
- O(2^n)<br>
지수형 빅오라고 부릅니다.<br>
데이터수의 증가율에 따라 연산 횟수의 지수적 증가라는 매우 무서운 증가율 보여주는 알고리즘입니다.<br>
사용하기에 매우 무리가 있는 알고리즘 입니다. 알고리즘이 이런 성능을 보인다면<br>
개선의 과정을 거쳐야합니다.

지금 까지 설명한 빅오 표기들의 성능을 정리하면 다음과 같습니다.<br>
O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(2^n)
