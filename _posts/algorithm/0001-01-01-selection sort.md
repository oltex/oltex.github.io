---
title: "선택 정렬(Selection Sort)"
categories:
  - algorithm
tags:
  - tag
---
> ## 개요

정렬 알고리즘 중 하나인 선택 정렬입니다.<br>
위치를 선택하고 선택한 위치에 맞는 원소를 넣어 정렬하는 알고리즘입니다.<br>
<br>
해당 순서에 넣을 위치는 정해져 있고 원소들 중에 선택하는 과정을 반복하여 정렬합니다.<br>
버블 정렬과 유사한 점이 많지만 버블 정렬보다는 효율적인 알고리즘입니다.
> ## 과정

선택 정렬이 이루어지는 과정입니다.<br>
선택 정렬은 가장 첫위치부터 선택하고 원소들을 탐색하여 정렬기준에 맞는 원소를<br>
집어넣는 과정을 거칩니다.
### 순서
다음과 같은 배열을 오름차순 정렬해 보겠습니다.
```
4 3 1 2
```
먼저 위 배열에서 위치를 선택해야 합니다 가장 첫 위치를 잡습니다.<br>
첫 위치에 집어넣어야하는 가장 작은 값을 찾습니다.<br>
1이 그 값에 해당함으로 1과 4의 위치를 바꿉니다.
```
1 3 4 2
```
이제 두번째 위치를 선택합니다.<br>
이미 정렬된 값을 제외한 값들 중에서 두번째 위치에 집어넣어야하는 가장 작은 값을 찾습니다.<br>
2가 그 값에 해당함으로 3과 2의 위치를 바꿉니다.
```
1 2 4 3
```
이제 세번째 위치를 선택합니다.<br>
이미 정렬된 값을 제외한 값들 중에서 세번째 위치에 집어넣어야하는 가장 작은 값을 찾습니다.<br>
3이 그 값에 해당함으로 4와 3을 바꿉니다.
```
1 2 3 4
```
나미저 원소들이 정렬이 다 이루어졌다면 마지막 원소는 자동으로 정렬되어 있기 때문에<br>
정렬 알고리즘을 종료합니다.
### 정리
이를 정리하자면
1. 배열의 첫 위치부터 선택하고
2. 남은 배열들을 순차적으로 탐색하여 가장 작은 원소를 선택한 다음
3. 그 원소를 선택된 위치에 집어넣는 작업(스왑)을
4. 배열의 마지막 위치까지 반복하여 차곡차곡 쌓아서 정렬합니다.

라고 볼 수 있습니다.
> ## 구현

선택 정렬을 코드로 구현해 보겠습니다.
```cpp
void Selection_Sort(int arr[], int size) {
	for (int i = 0; i < size - 1; ++i) {
		int index = i;
		for (int j = i + 1; j < size; ++j)
			if (arr[j] < arr[index])
				index = j;
		int temp = arr[i];
		arr[i] = arr[index];
		arr[index] = temp;
	}
}
```
```cpp
void main(void) {
	int arr[10] = { 3, 6, 2, 4, 1, 5, 7, 0, 9, 8 };
	Selection_Sort(arr, 10);
	for (auto iter : arr)
		std::cout << iter;
};
```
오름차순 정렬을 진행하는 선택정렬 함수입니다.<br>
매개 변수로 정렬할 배열인 arr과 그 배열의 사이즈인 size를 받고 있습니다.<br>
<br>
첫번째 for문은 정렬해야할 배열의 위치를 선택하기 위해 존재합니다.<br>
n개의 원소를 정렬할 때 n-1만큼 정렬 되었다면 나머지 1개도 자동으로 정렬되기 때문에<br>
size-1의 범위를 가집니다.<br>
<br>
index 변수는 내가 선택한 자리의 인덱스를 저장하고 있습니다.<br>
이를 다음 for문과 비교하여 최종적으로 i에 들어가야할 index를 찾습니다.<br>
<br>
두번째 for문은 모든 원소를 순회하며 선택 위치에 들어갈 원소를 찾습니다.<br>
j에 해당하는 원소가 index 원소에 존재하는 값보다 작다면 j를 index로 만듭니다.<br>
이때 j를 i+1로 정하는 이유는<br>
i보다 앞에 존재하는 원소는 이미 정렬이 완료된 상태라 생략하기 위함입니다.<br>
<br>
원소를 찾았으면 i와 해당하는 index를 스왑합니다.
> ## 복잡도

### 시간 복잡도
선택 정렬의 비교 연산, 이동 연산에 대한<br>
시간 복잡도를 계산해 보겠습니다.<br>
<br>
선택 정렬의 비교 연산은 O(n^2)의 시간 복잡도를 가지고 있습니다.<br>
또한 정렬이 완료되었음에도 모든 원소를 탐색하기 때문에<br>
최선, 평균, 최악의 경우 모두 O(n^2)의 시간 복잡도를 지닙니다.<br>
<br>
선택 정렬의 이동 연산은 O(n)의 시간 복잡도를 가지고 있습니다.<br>
조건문 같은 제약조건 없이 무조껀 이동이 이루어지므로<br>
최선, 평균, 최악의 경우 모두 O(n)의 시간 복잡도를 지닙니다.
### 공간 복잡도
선택 정렬은 주어진 배열 안에서 swap을 통해 정렬이 수행되므로<br>
O(n)의 공간 복잡도를 지닙니다.
