---
title: "삽입 정렬(Insertion Sort)"
categories:
  - algorithm
tags:
  - tag
---
> ## 개요

정렬 알고리즘 중 하나인 삽입 정렬입니다.<br>
원소가 들어갈 위치를 찾아 삽입을 통해 정렬하는 알고리즘입니다.<br>
<br>
배열의 이미 정렬된 부분과 비교하여 원소를 삽입하는 과정을 반복하여 정렬합니다.<br>
삽입 정렬은 이미 배열이 정렬되어 있는 상황에서 속도가 빠릅니다.
> ## 과정

삽입 정렬이 이루어지는 과정입니다.<br>
삽입 정렬은 앞에서부터 뒤로 원소를 선택하고 선택한 원소의 앞쪽에 해당하는<br>
배열과 비교하여 본인이 삽입될 위치를 정하는 과정을 거칩니다.<br>
<br>
다음과 같은 배열을 오름차순 정렬해보겠습니다.
```
4 2 3 1
```
삽입 정렬을 실행할 때 배열의 첫번째 원소는 비교해야될 대상이 없기 때문에<br>
이미 정렬되어 있다고 취급합니다.<br>
따라서 두번째 원소부터 실행하는것이 일반적입니다.<br>
<br>
두번째 원소인 2와 앞 배열인 4를 비교합니다.<br>
2는 4의 앞에 와야되니 4의 앞에 2를 집어넣습니다.
```
2 4 3 1
```
다음 세번째 원소인 3을 앞 베열인 2 4와 비교합니다.<br>
3은 2보다 크고 4보다 작기 때문에 4의 앞에 3을 집어넣습니다.
```
2 3 4 1
```
마지막으로 네번째 원소인 4를 앞 배열인 2 3 4와 비교합니다.<br>
마찬가지로 2보다 크니 1을 2의 앞에 집어넣습니다.
```
1 2 3 4
```
이로써 모든 정렬이 이루어졌습니다.

---
이 과정에서 생략된 내용이 삽입의 방식입니다.<br>
배열에서 원소를 삽입하기 위해서는<br>
삽입할 위치의 뒤에 존재하는 원소들을 한칸씩 뒤로 밀어야 되는 작업이 이루어져야 합니다.<br>
즉.
```
2 3 4 1
```
마지막 과정이였던 이 상황에서 1을 맨 앞으로 삽입하기 위해서는
```
1
2 3 4 1
2 3 4->4
2 3->3 4
2->2 3 4
```
1은 잠시 다른 변수로 빼둔 후 나머지 윈소를 뒤에서부터 앞으로 탐색하며<br>
1보다 큰 값이라면 뒤로 복사합니다.
```
1 2 3 4
```
이후 남은 자리에 1을 집어넣는 과정이 이루어집니다.

---
삽입 정렬의 과정을 정리하자면
1. 배열의 첫 원소부터 선택한 다음
2. 선택한 윈소를 다른 변수에 저장한 후
3. 이미 정렬된 배열들을 뒤에서부터 탐색하여, 
4. 선택한 원소가 들어갈 위치에 맞게 집어넣는 과정을(배열의 원소를 뒤로 복사)
5. 배열의 마지막 원소까지 반복하여 정렬합니다.

라고 볼 수 있습니다.
> ## 구현

삽입 정렬을 코드로 구현해 보겠습니다.<br>
오름차순 정렬을 하는 삽입 정렬 함수입니다.
```cpp
void Insertion_Sort(int arr[], int size) {
	for (int i = 1; i < size; ++i) {
		int data = arr[i];
		int j = i - 1;
		for (; j >= 0; --j) {
			if (arr[j] > data)
				arr[j + 1] = arr[j];
			else
				break;
		}
		arr[j + 1] = data;
	}
}
```
```cpp
void main(void) {
	int arr[10] = { 3, 6, 2, 4, 1, 5, 7, 0, 9, 8 };
	Insertion_Sort(arr, 10);
	for (auto iter : arr)
		std::cout << iter;
};
```
삽입 정렬 합수의 매개 변수로<br>
정렬할 배열인 arr과 그 배열의 사이즈인 size를 받습니다.<br>
<br>
첫번째 for문은 정렬할 원소를 선택하기 위해 존재합니다.<br>
첫번째 원소는 이미 정렬되어 있다고 취급하기 때문에 i는 1부터 시작합니다.<br>
정렬햐아할 원소의 값을 data변수에 저장합니다.<br>
<br>
두번째 for문은 삽입할 위치를 찾기 위해 이미 정렬된 배열을 탐색합니다.<br>
j는 이미 정렬된 배열의 마지막 인덱스인 i-1을 가집니다. 이를 0까지 반복합니다.<br>
만약 j번째 원소가 data보다 클 경우 j를 j+1(한칸 뒤)로 보냅니다.<br>
만약 j번쨰 원소가 data보다 작을 경우 break로 빠져나옵니다.<br>
<br>
이후 선택된 위치인 j+1에 data를 삽입합니다.
> ## 복잡도

### 시간 복잡도
삽입 정렬의 비교 연산, 이동 연산에 대해서<br>
각각의 시간 복잡도를 계산해 보겠습니다.<br>
<br>
삽입 정렬의 비교 연산은 O(n^2)의 시간 복잡도를 지닙니다.<br>
단 이미 정렬되어 있는 상황에는 break문을 통해 중단하므로<br>
최선의 경우 O(n), 최악의 경우O(n^2)의 시간 복잡도를 지닙니다.<br>
<br>
삽입 정렬의 이동 연산은 O(n^2)의 시간 복잡도를 지닙니다.<br>
이동 연산 또한 break문을 통해 이중 for문 안의 이동연산을 중단시킬수 있으므로<br>
최선의 경우 O(n) 최악의 경우O(n^2)의 시간 복잡도를 지닙니다.
### 공간 복잡도
삽입 정렬은 주어진 배열 안에서 swap을 통해 정렬이 수행되므로<br>
O(n)의 공간 복잡도를 지닙니다.
