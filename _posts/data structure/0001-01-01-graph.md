---
title: "그래프(Graph)"
categories:
  - data structure
tags:
  - tag
---
> ## 연결 리스트

### 노드
```cpp
template<typename _Ty>
struct Node final {
	explicit Node(const _Ty& value) :
		_value(value) {
	}
	_Ty _value;
	bool _visit = false;
	std::list<Node*> _adjacent;
};
```
### 그래프
```cpp
template<typename _Ty>
class Graph {
public:
	template<template<typename> typename _Search>
	using iterator = Iterator<_Ty, _Search>;
	friend class Iterator<_Ty, DFS>;
	friend class Iterator<_Ty, BFS>;
public:
	void Insert(const _Ty& value);
	void Erase(const _Ty& value);
	void Add_Edge(const _Ty& from, const _Ty& to);
	void Remove_Edge(const _Ty& from, const _Ty& to);
private:
	std::vector<Node<_Ty>> _node;
};
```
```cpp
template<typename _Ty>
void Graph<_Ty>::Insert(const _Ty& value) {
	_node.emplace_back(value);
}

template<typename _Ty>
void Graph<_Ty>::Erase(const _Ty& value) {
	auto iter = std::find_if(_node.begin(), _node.end(), [&](Node<_Ty> temp) {
		return value == temp._value;
		});
	if (iter == _node.end())
		return;

	for (auto sour : iter->_adjacent)
		sour->_adjacent.remove(&*iter);

	_node.erase(iter);
}

template<typename _Ty>
void Graph<_Ty>::Add_Edge(const _Ty& from, const _Ty& to) {
	auto iter_from = std::find_if(_node.begin(), _node.end(), [&](Node<_Ty> temp) {
		return from == temp._value;
		});
	auto iter_to = std::find_if(_node.begin(), _node.end(), [&](Node<_Ty> temp) {
		return to == temp._value;
		});
	if (iter_from == _node.end() || iter_to == _node.end())
		return;

	iter_from->_adjacent.emplace_back(&*iter_to);
	iter_to->_adjacent.emplace_back(&*iter_from);
}

template<typename _Ty>
void Graph<_Ty>::Remove_Edge(const _Ty& from, const _Ty& to) {
	auto iter_from = std::find_if(_node.begin(), _node.end(), [&](Node<_Ty> temp) {
		return from == temp._value;
		});
	auto iter_to = std::find_if(_node.begin(), _node.end(), [&](Node<_Ty> temp) {
		return to == temp._value;
		});
	if (iter_from == _node.end() || iter_to == _node.end())
		return;

	iter_from->_adjacent.remove(&*iter_to);
	iter_to->_adjacent.remove(&*iter_from);
}
```
### 반복자
```cpp
template<typename _Ty>
class Graph;

template<typename _Ty, template<typename> typename _Search>
class Iterator final {
public:
	explicit Iterator(void) = default;
	Iterator(Graph<_Ty>& graph);
	void operator=(Graph<_Ty>& graph);
public:
	void Search(const _Ty& _value);
private:
	std::vector<Node<_Ty>>* _node = nullptr;
	_Search<_Ty> _search;
};
```
```cpp
template<typename _Ty, template<typename> typename _Search>
Iterator<_Ty, _Search>::Iterator(Graph<_Ty>& graph)
	: _node(graph._node) {
}

template<typename _Ty, template<typename> typename _Search>
void Iterator<_Ty, _Search>::operator=(Graph<_Ty>& graph) {
	_node = &graph._node;
}

template<typename _Ty, template<typename> typename _Search>
void Iterator<_Ty, _Search>::Search(const _Ty& _value) {
	Node<_Ty>* node = nullptr;
	for (auto& iter : *_node) {
		iter._visit = false;
		if (_value == iter._value)
			node = &iter;
	}
	if (nullptr == node)
		return;
	_search(node);
	std::cout << std::endl;
}
```
### 탐색
```cpp
template<typename _Ty>
class DFS final {
public:
	void operator()(Node<_Ty>* node);
private:
	std::stack<Node<_Ty>*> _stack;
};

template<typename _Ty>
class BFS final {
public:
	void operator()(Node<_Ty>* node);
private:
	std::queue<Node<_Ty>*> _queue;
};
```
```cpp
template<typename _Ty>
void DFS<_Ty>::operator()(Node<_Ty>* node) {
	std::cout << node->_value << ' ';
	node->_visit = true;
	_stack.emplace(node);

	while (!_stack.empty()) {
		Node<_Ty>* next = nullptr;
		for (auto iter : _stack.top()->_adjacent)
			if (false == iter->_visit) {
				next = &*iter;
				break;
			}
		if (nullptr != next) {
			std::cout << next->_value << ' ';
			next->_visit = true;
			_stack.emplace(next);
		}
		else
			_stack.pop();
	}
}

template<typename _Ty>
void DFS<_Ty>::operator()(Node<_Ty>* node) {
	std::cout << node->_value << ' ';
	node->_visit = true;

	for (auto iter : node->_adjacent)
		if (false == iter->_visit)
			operator()(&*iter);
}

template<typename _Ty>
void BFS<_Ty>::operator()(Node<_Ty>* node) {
	_queue.emplace(node);

	while (!_queue.empty()) {
		std::cout << _queue.front()->_value << ' ';
		_queue.front()->_visit = true;
		for (auto iter : _queue.front()->_adjacent)
			if (false == iter->_visit)
				_queue.emplace(iter);
		_queue.pop();
	}
}
```
### 메인
```cpp
void func(void) {

	Graph<char> graph;
	Graph<char>::iterator<DFS> iter_DFS;
	Graph<char>::iterator<BFS> iter_BFS;

	graph.Insert('A');
	graph.Insert('B');
	graph.Insert('C');
	graph.Insert('D');
	graph.Insert('E');
	graph.Insert('F');
	graph.Insert('G');

	graph.Add_Edge('A', 'B');
	graph.Add_Edge('A', 'D');
	graph.Add_Edge('B', 'C');
	graph.Add_Edge('D', 'E');
	graph.Add_Edge('E', 'F');
	graph.Add_Edge('E', 'G');

	iter_DFS = graph;
	iter_DFS.Search('A');
	iter_DFS.Search('C');
	iter_DFS.Search('E');
	iter_DFS.Search('G');

	iter_BFS = graph;
	iter_BFS.Search('A');
	iter_BFS.Search('C');
	iter_BFS.Search('E');
	iter_BFS.Search('G');
}
```
